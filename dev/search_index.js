var documenterSearchIndex = {"docs":
[{"location":"DDEVertex/#Experimental-DDE-Tutorial-1","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"An IJulia notebook corresponding to this tutorial will be available on GitHub soon.","category":"page"},{"location":"DDEVertex/#Topics-covered-in-this-tutorial-include:-1","page":"Experimental DDE Tutorial","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"constructing a watts_strogatz graph\ndiffusion delay differential equation (DDE)\nparameter handling with DDE's\nstiff equations\nKuramoto Delay Model","category":"page"},{"location":"DDEVertex/#Network-Diffusion-1","page":"Experimental DDE Tutorial","title":"Network Diffusion","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"This example explains the use of delay differential equations (DDE's) in NetworkDynamics.jl by modeling a simple diffusion on an undirected ring network with delay.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. The rate of change of state v_i in this artificial example is described by the delay value of v_i with delay Tau and its difference with its neighbors with coupling strength sigma. We obtain the following ordinary differential equation","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"beginaligned\r\ndot v_i = - v_i(Tau) - sigma * sum_i=1^N A_ij (v_i - v_j)\r\nendaligned","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"DDEVertex/#Modeling-diffusion-with-delay-in-NetworkDynamics.jl-1","page":"Experimental DDE Tutorial","title":"Modeling diffusion with delay in NetworkDynamics.jl","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"From the equation above we see that in this model the dynamics of the nodes consist of internal dynamics as well as a coupling term with the neighboring nodes. In NetworkDynamics.jl the interactions with the neighbors are described by equations for the edges.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"function diffusionedge!(e, v_s, v_d, p, t)\r\n   # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\r\n   e .= .1 * (v_s .- v_d)\r\n   nothing\r\nend\r\nnothing # hide","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"The internal dynamics are determined by the delay value dot v_i = v_i(Tau) and are described in the vertex function with help of the history array h_v containing the delay values of the vertex.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"function diffusionvertex!(dv, v, e_s, e_d, h_v, p, t)\r\n   # usually dv, v, e_s, e_d, h_v are arrays, hence we use the broadcasting operator .\r\n   # h_v is the history array of the vertices\r\n   dv .= -h_v\r\n   # edges for which v is the source\r\n   for e in e_s\r\n       dv .-= e\r\n   end\r\n   # edges for which v is the destination\r\n   for e in e_d\r\n       dv .+= e\r\n   end\r\n   nothing\r\nend\r\nnothing # hide","category":"page"},{"location":"DDEVertex/#Constructing-the-Network-Dynamics-1","page":"Experimental DDE Tutorial","title":"Constructing the Network Dynamics","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Constructing the network dynamics is straightforward","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"using LightGraphs\r\n\r\n### Defining a graph\r\n\r\nN = 20 # number of nodes\r\nk = 8  # average degree\r\ng = watts_strogatz(N, k, 0.) # ring-network","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"The Watts-Strogatz algorithm constructs a regular-ring network with N nodes, k neighbors and a probability p of rewiring links, which is chosen as p=0 here.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"using NetworkDynamics\r\n\r\nnd_diffusion_vertex = DDEVertex(f! = diffusionvertex!, dim = 1)\r\nnd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)\r\n\r\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Now we hand over the functions we have defined above to the constructors DDEVertex and StaticEdge, adding information on the dimension of variables at each edge or node with keyword dim. The wrapper function DDEVertex is a new feature describing internal delay dynamics of nodes. The resulting objects can then be delivered to the key constructor network_dynamics, which adds topological information of graph g and returns an DDEFunction, which is compatible with the solvers of DifferentialEquations.jl.","category":"page"},{"location":"DDEVertex/#Simulation-1","page":"Experimental DDE Tutorial","title":"Simulation","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"First we set the initial conditions, the time-interval tspan, construct the history function h(x,p,t) and set the parameters p, which are now extended to take parameters for the delay-time too.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"\r\nx0 = randn(N) # random initial conditions\r\ntspan = (0., 10.) #time interval\r\n\r\n# history function defaults to all 1. and is in-place to save allocations\r\nh(out, p, t) = (out .= 1.)\r\n\r\n#parameters p = (vertex parameters, edge parameters, delay time)\r\np = (nothing, nothing, 1.)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Then we solve the diffusion problem. The constructor DDEProblem is from the package DealyDiffEq.jl and wraps up the DDEFunction with the initial conditions x0 , the history function h , time-interval tspan and parameters p, which can than be handed over to the solve method.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"using OrdinaryDiffEq\r\nusing DelayDiffEq\r\n\r\ndde_prob = DDEProblem(nd, x0, h, tspan, p)\r\nsol = solve(dde_prob, MethodOfSteps(Tsit5()))","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"We solve the problem with delay on the time interval 0 10 with the Tsit5() algorithm, which is the Tsitouras 5/4 Runge-Kutta method (a free 4th order interpolant), recommended for solving non-stiff problems. The additional algorithm MethodOfSteps translates an OrdinaryDiffEq.jl ODE solver method into a method for delay differential equations which is highly efficient.","category":"page"},{"location":"DDEVertex/#Bonus:-Two-independet-diffusions-1","page":"Experimental DDE Tutorial","title":"Bonus: Two independet diffusions","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"In this extension of the first example, we will have two independent diffusions on the same network with variables x and phi, such that the dim=2. First we construct the network_dynamics-objects.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"nd_diffusion_vertex_2 = DDEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :ϕ])\r\nnd_diffusion_edge_2 = StaticDelayEdge(f! = diffusionedge!, dim = 2)\r\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Secondly, the initial conditions are generated, where the first N values correspond to variable x and the values with indices from N+1 to 2N to state-variable ϕ, where x sim  N(01); ϕ sim N(01)^2. The parameter value for the delay Tau is set to 1.0.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"x0_2 = Array{Float64,1}(vec([randn(N).-10 randn(N).^2]')) # x ~ \\mathcal{N}(0,1); ϕ ~ \\mathcal{N}(0,1)^2\r\n\r\np = (nothing, nothing, 1.) # p = (vertexparameters, edgeparameters, delaytime)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Now we can define the DDEProblemand then solve it. The DDEProblem is a wrapper function, which delivers an ODEFunction, which is compatible with the solvers of DelayDiffEq.jl.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"dde_prob_2 = DDEProblem(nd_2, x0_2, h, tspan, p)\r\nsol_2 = solve(dde_prob_2, MethodOfSteps(Tsit5()));\r\nplot(sol_2, legend=false)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"As a solver we use again Tsit5() with the MethodOfSteps-algorithm.","category":"page"},{"location":"DDEVertex/#Kuramoto-model-with-delay-1","page":"Experimental DDE Tutorial","title":"Kuramoto model with delay","text":"","category":"section"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"An additional example which will be explained in the following is the Kuramoto model. Instead of modeling a simple diffusion on an undirected ring network, we will use the Kuramoto model for the vertices and the edges but keep delay and the Watts-Strogatz graph as in the examples above.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Again, the interactions with the neighbors are described through the edge function. Unlike the diffusion example, here the edges now have a delay. For this reason we introduce the history arrays for the destination vertices and source vertices.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"function kuramoto_delay_edge!(e, v_s, v_d, h_v_s, h_v_d, p, t)\r\n    # The coupling is no longer symmetric, so we need to store BOTH values (see tutorials for details)\r\n    e[1] = p * sin(v_s[1] - h_v_d[1])\r\n    e[2] = p * sin(h_v_s[1] - v_d[1])\r\n    nothing\r\nend\r\nnothing # hide","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Now, the contributions of the edges are summed up in each vertex so that we can define the vertex function for the Kuramoto model.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"function kuramoto_vertex!(dv, v, e_s, e_d, p, t)\r\n    dv[1] = p\r\n    for e in e_s\r\n        dv[1] -= e[1]\r\n    end\r\n    for e in e_d\r\n        dv[1] -= e[2]\r\n    end\r\n    nothing\r\nend","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"As for the diffusion example, we now hand over the defined functions for the Kuramoto edges and vertices to the constructors DDEVertex and StaticEdge of NetworkDynamics.jl.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"kdedge! = StaticDelayEdge(f! = kuramoto_delay_edge!, dim=2)\r\nkdvertex! = ODEVertex(f! = kuramoto_vertex!, dim = 1)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Note that the edges have the dimension two, since there is no more symmetric coupling for the Kuramoto case. Accordingly, we have to set the keywork argument dim of StaticDelayEdge to two. The returned objects (nd_diffusion_vertex and nd_diffusion_edge) are passed to the key construcor network_dynamics together with informations of the graph which are contained in g.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"nd! = network_dynamics(kdvertex!, kdedge!, g)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"The object nd! returned by network_dynamics, is compatible with the solvers of DifferentialEquations.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"Afterwards, random initial conditions are set for all N nodes, as well as the simulation time tspan, the eigenfrequencies ω of the N vertices, and the parameters p for the edges, the vertices, and the delay. Since we are dealing with a system containg a time delay, we need to set the history function h as for the examples above. The history function sets all default entries to 1.0 and is in-place to save allocations.","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"x0 = randn(N) # random initial conditions\r\n# history function defaults to all 1. and is in-place to save allocations\r\nh(out, p, t) = (out .= 1.)\r\n# p = (vertexparameters, edgeparameters, delaytime)\r\nω = randn(N)\r\nω .-= sum(ω)/N\r\np = (ω, 2., 1.)\r\ntspan = (0.,20.)","category":"page"},{"location":"DDEVertex/#","page":"Experimental DDE Tutorial","title":"Experimental DDE Tutorial","text":"As described for the diffusion exmaple above, the constructor DDEProblem is used to provide an object that can be solved using the solve method.","category":"page"},{"location":"Multithreading/#Multi-Threading-1","page":"Multi-Threading","title":"Multi-Threading","text":"","category":"section"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"Since version 0.3.0 multi-threading via the Threads.@threads macro is possible. This allows julia to integrate different nodes and edges in different threads, and can lead to significant performance gains on parallel architectures. To enable multi-threading call network_dynamics with the keyword argument parallel=true.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"network_dynamics(vertices!, edges!, graph, parallel=true)","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"In order for this to take effect, multiple threads have to be available. This is achieved by setting the environment variable JULIA_NUM_THREADS before starting Julia.  To start Julia from a bash shell and with 4 threads use:","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"$ env JULIA_NUM_THREADS=4 julia","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"If you are using Juno for the Atom text editor JULIA_NUM_THREADS is set to the number of physical cores of your processor by default. This is also the number of threads we recommend to use.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"note: Note\nThe thread handling causes an overhead in the order of 20 μs per call to the ODE function which might impair performance on small networks (<100 nodes) or on single core machines. In theses cases network_dynamics can be called without any additional arguments, since parallel defaults to false.","category":"page"},{"location":"Multithreading/#","page":"Multi-Threading","title":"Multi-Threading","text":"For more information on setting environment varibales see the Julia documentation.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"EditURL = \"<unknown>/../examples/heterogeneous_system.jl\"","category":"page"},{"location":"heterogeneous_system/#Modeling-a-heterogeneous-system-1","page":"Heterogeneous systems","title":"Modeling a heterogeneous system","text":"","category":"section"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"One of the main purposes of NetworkDynamics.jl is to facilitate modeling coupled systems with heterogenities. This means that components can differ in their parameters as well as in their dynamics.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"A notebook corresponding to this tutorial can be found here.","category":"page"},{"location":"heterogeneous_system/#Heterogenous-parameters-1","page":"Heterogeneous systems","title":"Heterogenous parameters","text":"","category":"section"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"We start by setting up a simple system of Kuramoto oscillators.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"using NetworkDynamics, OrdinaryDiffEq, Plots, LightGraphs\n\n\nN = 8\ng = watts_strogatz(N,2,0) # ring network\n\nfunction kuramoto_edge!(e, θ_s, θ_d, K, t)\n    e[1] = K * sin(θ_s[1] - θ_d[1])\nend\n\nfunction kuramoto_vertex!(dθ, θ, e_s, e_d, ω, t)\n    dθ[1] = ω\n    oriented_edge_sum!(dθ, e_s, e_d)\nend\n\nvertex! = ODEVertex(f! = kuramoto_vertex!, dim = 1, sym=[:θ])\nedge!   = StaticEdge(f! = kuramoto_edge!, dim = 1)\nnd! = network_dynamics(vertex!, edge!, g);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Introducing genous parameters is as easy as defining an array. Here the vertex parameters are genous, while the edges share the same coupling parameter K.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"ω = collect(1:N)./N\nω  .-= sum(ω)/N\nK  = 3.\np  = (ω, K); # p[1] vertex parameters, p[2] edge parameters\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Integrate and plot","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0 = collect(1:N)./N\nx0 .-= sum(x0)./N\ntspan = (0., 10.)\nprob = ODEProblem(nd!, x0, tspan, p)\nsol = solve(prob, Tsit5())\nplot(sol, ylabel=\"θ\")","category":"page"},{"location":"heterogeneous_system/#Heterogenous-dynamics-1","page":"Heterogeneous systems","title":"Heterogenous dynamics","text":"","category":"section"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Two paradigmatic modifications of the node model above are static nodes and nodes with inertia. A static node has no internal dynamics and instead fixes the variable at a constant value. A Kuramoto model with inertia consits of two interal variables leading to more complicated (and for many applications more realistic) local dynamics.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"static! = StaticVertex(f! = (θ, e_s, e_d, c, t) -> θ .= c, dim = 1, sym = [:θ])\n\n\nfunction kuramoto_inertia!(dv, v, e_s, e_d, P, t)\n    dv[1] = v[2]\n    dv[2] = P - 1. * v[2]\n    for e in e_s\n        dv[1] -= e[1]\n    end\n    for e in e_d\n        dv[1] += e[1]\n    end\nend\n\ninertia! = ODEVertex(f! = kuramoto_inertia!, dim = 2, sym= [:θ, :ω]);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Since now we model a system with genous node dynamics we can no longer straightforwardly pass a single VertexFunction to network_dynamics but instead have to hand over an Array.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"vertex_array    = Array{VertexFunction}([vertex! for i = 1:N])\nvertex_array[1] = static!\nvertex_array[5] = inertia! # index should correspond to the node's index in the graph\nnd_hetero!   = network_dynamics(vertex_array, edge!, g);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"Now we have to take a bit more care with defining initial conditions and parameters. For the static! node the initial condition has to match its parameter. For simplicity we use the same parameters as above.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0[1] = ω[1];\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"The node with inertia is two-dimensional, hence we need to specify two initial conditions. For the first dimension we keep the ic from above and insert! another one into x0 at the correct index.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"inertia_ic_2 = 5\ninsert!(x0, 6, inertia_ic_2);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"x0[1:4] holds ic for nodes 1 to 4, x0[5:6] holds the two initial conditions for node 5, x0[7:9] holds ic for nodes 6 to 8.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"prob_hetero = ODEProblem(nd_hetero!, x0, tspan, p)\nsol_hetero = solve(prob_hetero, Rodas4());\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"For clarity we plot only the variables refering to the oscillator's angle θ and color them according to their type.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"membership = ones(Int64, N)\nmembership[1] = 2\nmembership[5] = 3\nnodecolor = [colorant\"lightseagreen\", colorant\"orange\", colorant\"darkred\"];\nnodefillc = reshape(nodecolor[membership], 1, N);\n\nvars = syms_containing(nd_hetero!, :θ);\nplot(sol_hetero, ylabel=\"θ\", vars=vars, lc = nodefillc)","category":"page"},{"location":"heterogeneous_system/#Components-with-algebraic-constraints-1","page":"Heterogeneous systems","title":"Components with algebraic constraints","text":"","category":"section"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"If one of the network components contains an algebraic as well as dynamical component, then there is the option to supply a mass matrix for the given component. In general this will look as follows:","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"function edgeA!(de, e, v_s, v_d, p, t)\n    de[1] = f(e, v_s, v_d, p, t) # dynamic variable\n    e[2]  = g(e, v_s, v_d, p, t) # static varibale\nend\n\nM = zeros(2,2)\nM[1,1] = 1\n\nnd_edgeA! = ODEEdge(f! = edgeA!, dim = 2, mass_matrix = M);\nnothing #hide","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This handles the second equations as 0 = M[2,2] * de[2] = g(e, v_s, v_d, p, t) - e[2].","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"See the example kuramoto_plasticity.jl and the discussion on github for more details.","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"","category":"page"},{"location":"heterogeneous_system/#","page":"Heterogeneous systems","title":"Heterogeneous systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"parameters/#Parameter-handling-1","page":"Parameter handling","title":"Parameter handling","text":"","category":"section"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Let nd! be an ODEFunction returned by network_dynamics, e.g.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"nd! = network_dynamics(vertices!, edges!, graph)","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"then the behaviour of nd! has the signature (dx, x, t, p) and its behaviour changes with the type of parameters p being passed.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"When p is an Array, a Dict, a struct... then the entire object is passed to each VertexFunction and EdgeFunction.\nWhen p = (p_v, p_e) is a Tuple of two values, then the first value will be passed to all vertices and the second to all edges.\nIf p = (p_v_arr, p_e_arr) is a Tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then the edges or nodes receive only the parameter with the corresponding index.\nIf all nodes and/or edges have no internal parameters the value nothing may be passed. Using nothing instead of dummy parameters is usually faster, since then less data are copied.\nIf you are working with delay differential equations the parameter tuple should have a third entry that specifies the delay time, p = (p_v, p_e, delay_time).","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Another option for specifying heterogeneous parameters is to make each VertexFunction a callable struct with the parameters hardcoded as fields. This approach is used in PowerDynamics.jl. However it provides considerably less flexibility and interoperability with other packages.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"For its greater speed and flexibility in modeling we recommend to use the tuple syntax.","category":"page"},{"location":"parameters/#Compatability-with-DiffEqFlux-1","page":"Parameter handling","title":"Compatability with DiffEqFlux","text":"","category":"section"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Most of the sensitivity algorithms that DiffEqFlux makes use of assume that the parameters p are a subtype of AbstractArray. Therefore they are not compatible with the tuple syntax.TrackerAdjoint does not have these limitations but works best on out-of-place problems. Unfortunately, network_dynamics returns an ODEProblem that is in-place (mutating its inputs) leading to slow performance with Tracker.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"However, wrapping the function in such a way that it accepts arrays of parameters that are later pasted into the tuple syntax sidesteps these issues and enables the use of adjoint methods. Depending on the use case such a wrapper might look like this:","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"function nd_wrapper!(dx, x, p, t)\n  nd!(dx, x, (p, nothing), t)\nend","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"nd_wrapper! should now work with BacksolveAdjoint and InterpolatingAdjoint. At the moment we recommend this way for combining NetworDynamics and DiffEqFlux.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Forward mode (ForwardDiff.jl) and source-to-source (Zygote.jl)  automatic differentiation  is not fully-supported yet. For more detailed discussion see this issue.","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"Further resources:","category":"page"},{"location":"parameters/#","page":"Parameter handling","title":"Parameter handling","text":"DiffEqSensitivity algorithms","category":"page"},{"location":"Library/#Library-1","page":"Library","title":"Library","text":"","category":"section"},{"location":"Library/#Public-Interface-1","page":"Library","title":"Public Interface","text":"","category":"section"},{"location":"Library/#","page":"Library","title":"Library","text":"The following functions are designed for public use","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"","category":"page"},{"location":"Library/#","page":"Library","title":"Library","text":"network_dynamics\nStaticVertex\nODEVertex\nDDEVertex\nStaticEdge\nODEEdge\nStaticDelayEdge\nsyms_containing\nidx_containing","category":"page"},{"location":"Library/#NetworkDynamics.network_dynamics","page":"Library","title":"NetworkDynamics.network_dynamics","text":"network_dynamics(vertices!, edges!, g; parallel = false)\n\nAssembles the the dynamical equations of the network problem into an ODEFunction compatible with the DifferentialEquations.jl solvers. Takes as arguments an array of VertexFunctions vertices!, an array of EdgeFunctions edges! and a LightGraph.jl object g. The optional argument parallel is a boolean value that denotes if the central loop should be executed in parallel with the number of threads set by the environment variable JULIANUMTHREADS.\n\n\n\n\n\nPromotes StaticEdge to StaticDelayEdge if there is a DDEVertex\n\n\n\n\n\nPromotes ODEVertex to DDEVertex if there is a StaticDelayEdge\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.ComponentFunctions.StaticVertex","page":"Library","title":"NetworkDynamics.ComponentFunctions.StaticVertex","text":"StaticVertex(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static node and has to respect the following calling syntax\n\nf!(v, e_s, e_t, p, t) -> nothing\n\nHere  v, p and t are the usual arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ComponentFunctions.ODEVertex","page":"Library","title":"NetworkDynamics.ComponentFunctions.ODEVertex","text":"ODEVertex(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf!(dv, v, e_s, e_t, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ComponentFunctions.DDEVertex","page":"Library","title":"NetworkDynamics.ComponentFunctions.DDEVertex","text":"DDEVertex(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic node and has to respect the following calling syntax\n\nf!(dv, v, e_s, e_t, h, p, t) -> nothing\n\nHere dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively. h is the history array for v.\n\ndim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * dv = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ComponentFunctions.StaticEdge","page":"Library","title":"NetworkDynamics.ComponentFunctions.StaticEdge","text":"StaticEdge(f!, dim, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a static edge and has to respect the following calling syntax\n\nf!(e, v_s, v_t, p, t) -> nothing\n\nHere  e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ComponentFunctions.ODEEdge","page":"Library","title":"NetworkDynamics.ComponentFunctions.ODEEdge","text":"ODEEdge(f!, dim, mass_matrix, sym)\n\nWrapper that ensures compatibility of a mutating function f! with the key constructor network_dynamics.\n\nf!  describes the local behaviour at a dynamic edge and has to respect the following calling syntax\n\nf!(de, e, v_s, v_t, p, t) -> nothing\n\nHere  de, e, p and t are the usual arguments, while v_s and v_d are arrays containing the vertices which are the source and destination of the described edge.\n\ndim is the number of independent variables in the edge equations and sym is an array of symbols for these variables. For more details see the documentation. mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the system M * de = f! will be solved.\n\nFor more details see the documentation.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.ComponentFunctions.StaticDelayEdge","page":"Library","title":"NetworkDynamics.ComponentFunctions.StaticDelayEdge","text":"Like a static edge but with extra arguments for the history of the source and destination vertices. This is NOT a DDEEdge.\n\n\n\n\n\n","category":"type"},{"location":"Library/#NetworkDynamics.Utilities.syms_containing","page":"Library","title":"NetworkDynamics.Utilities.syms_containing","text":"Find all symbols present in a network_dynamics that contain the string or symbol str\n\n\n\n\n\n","category":"function"},{"location":"Library/#NetworkDynamics.Utilities.idx_containing","page":"Library","title":"NetworkDynamics.Utilities.idx_containing","text":"Find all indices of variables with symbols containing the string or symbol str\n\n\n\n\n\n","category":"function"},{"location":"directed_and_weighted_graphs/#Neurodynamic-model-of-synchronization-in-the-human-brain-1","page":"Directed and weighted graphs","title":"Neurodynamic model of synchronization in the human brain","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"An IJulia notebook corresponding to this tutorial is available on GitHub.","category":"page"},{"location":"directed_and_weighted_graphs/#Topics-covered-in-this-tutorial-include:-1","page":"Directed and weighted graphs","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"constructing a directed, weighted graph from data\nsome useful macros\nparameter handling\nstiff equations","category":"page"},{"location":"directed_and_weighted_graphs/#The-FitzHugh-Nagumo-model-1","page":"Directed and weighted graphs","title":"The FitzHugh-Nagumo model","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Dynamics of spiking neurons have been described in a simplified manner by the FitzHugh-Nagumo model.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u   =  u - fracu^33 - v \ndot v  =  u + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Here u is a fast, excitatory variable corresponding to the membrane potential and v is a slower, inhibitory varibale. varepsilon is a parameter separating these time-scales, and a is a control parameter.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In simplified models of the brain, such relaxation oscillators may be used to model individual neurons, clusters of neurons or even larger areas in the brain. The FitzHugh-Nagumo model has been widely used for studying synchronization in neuronal activity, which in turn has been connected to physiological phenomena such as epileptic seizures.","category":"page"},{"location":"directed_and_weighted_graphs/#Coupling-relaxation-oscillators-1","page":"Directed and weighted graphs","title":"Coupling relaxation oscillators","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"While different coupling schemes for FitzHugh-Nagumo oscillators have been proposed, in this tutorial we focus on coupling of the excitatory variables via electrical gap junctions, as described by the following system of equations.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"beginaligned\nvarepsilon dot u_i  =  u_i - fracu_i^33 - v_i - sigma sum_j=1^N G_ij(u_i - u_j) \ndot v_i  =   u_i + a\nendaligned","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"This is a simple diffusive coupling mediated by the difference between activation potentials in pairs of neurons. A similar coupling term was introduced in the \"getting started\" tutorial.","category":"page"},{"location":"directed_and_weighted_graphs/#The-network-topology-a-brain-atlas-1","page":"Directed and weighted graphs","title":"The network topology - a brain atlas","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"In the following we will use a directed and weigthed network encoding the strength and directionality of coupling between 90 different areas of the brain [Nathalie Tzourio-Mazoyer et al., 2002, Neuroimage].","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The network weight matrix is given as a text file containing 90 lines with 90 numbers representing the coupling strength and separated by commas ,. The data can be conveniently read into a matrix with the DelimitedFiles module.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using DelimitedFiles\n# adjust the load path for your filesystem!\nG = readdlm(joinpath(@__DIR__, \"../../examples/Norm_G_DTI.txt\"), ',', Float64, '\\n')\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The data structure for directed, weighted graphs is provided by the package SimpleWeightedGraphs.jl which is based on LightGraphs.jl.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using SimpleWeightedGraphs, LightGraphs\n\n# First we construct a weighted, directed graph\ng_weighted = SimpleWeightedDiGraph(G)\n\n# For later use we extract the edge.weight attributes\n# . is the broadcasting operator and gets the attribute :weight for every edge\nedge_weights = getfield.(collect(edges(g_weighted)), :weight)\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Setting-up-the-ODEProblem-1","page":"Directed and weighted graphs","title":"Setting up the ODEProblem","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Defining VertexFunction and EdgeFunction is similar to the example before. The macros @inline and Base.@propagate_inbounds give the compiler more freedom to compile efficient code. For more details see the julia documentation.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using NetworkDynamics\n\n@inline Base.@propagate_inbounds function fhn_electrical_vertex!(dv, v, e_s, e_d, p, t)\n    dv[1] = v[1] - v[1]^3 / 3 - v[2]\n    dv[2] = (v[1] - a) * ϵ\n    for e in e_s\n        dv[1] -= e[1]\n    end\n    for e in e_d\n        dv[1] += e[1]\n    end\n    nothing\nend\n\n@inline Base.@propagate_inbounds function electrical_edge!(e, v_s, v_d, p, t)\n    e[1] =  p * (v_s[1] - v_d[1]) # * σ\n    nothing\nend\n\nodeelevertex = ODEVertex(f! = fhn_electrical_vertex!, dim = 2, sym=[:u, :v]);\nelectricaledge = StaticEdge(f! = electrical_edge!, dim = 1)\n\nfhn_network! = network_dynamics(odeelevertex, electricaledge, g_weighted)\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Note that the multiplication with the coupling strength sigma has been commented out. Since sigma is the same for every edge we can absorb this multiplication into the edge weight parameter p. Since our network has almost 8000 edges, this saves 8000 multiplications at every function call and leads to an 8-fold increase in performance.","category":"page"},{"location":"directed_and_weighted_graphs/#Parameter-handling-1","page":"Directed and weighted graphs","title":"Parameter handling","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"# Defining global parameters\n\nN = 90         # number of nodes\nconst ϵ = 0.05 # global variables that are accessed several times should be declared `const`\nconst a = .5\nconst σ = .5\n\n# Tuple of parameters for nodes and edges\n\np = (nothing, σ * edge_weights)\n\n# Initial conditions\n\nx0 = randn(2N) * 5\n\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The behaviour of network_dynamics changes with the type of parameters p being passed. When p is an Array, the entire Array will be passed to each VertexFunction and EdgeFunction. When p is a tuple of two Arrays with lengths corresponding to the number of nodes and number of edges respectively, then network_dynamics passes only the edge or node parameters with the index of the edge or node. When there are no parameters for either edges or nodes the value nothing may be used.","category":"page"},{"location":"directed_and_weighted_graphs/#Solving-the-system-1","page":"Directed and weighted graphs","title":"Solving the system","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"Now we are ready to create an ODEProblem. Since for some choices of parameters the FitzHugh-Nagumo model is stiff (i.e. numerically unstable), we use a solver with automated stiffness detection. Such a solver switches to a more stable solver only when the solution enters a region of phase space where the problem is numerically unstable. In this case we use Tsit5 and switch to TRBDF2 when necessary. AutoTsit5 is the switching version of the Tsit5 algorithm.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using OrdinaryDiffEq\n\ntspan = (0., 200.)\nprob  = ODEProblem(fhn_network!, x0, tspan, p)\nsol   = solve(prob, AutoTsit5(TRBDF2()));\nnothing # hide","category":"page"},{"location":"directed_and_weighted_graphs/#Plotting-1","page":"Directed and weighted graphs","title":"Plotting","text":"","category":"section"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"The plot of the excitatory variables shows that they synchronize for this choice of parameters.","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"using Plots\n\nplot(sol, vars = idx_containing(fhn_network!, :u), legend = false, ylim=(-5, 5));\nsavefig(\"fhnsync.svg\") # hide","category":"page"},{"location":"directed_and_weighted_graphs/#","page":"Directed and weighted graphs","title":"Directed and weighted graphs","text":"(Image: )","category":"page"},{"location":"SDEVertex/#SDE-Tutorial-1","page":"SDE Tutorial","title":"SDE Tutorial","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"An IJulia notebook corresponding to this tutorial will be available on GitHub soon.","category":"page"},{"location":"SDEVertex/#Topics-covered-in-this-tutorial-include:-1","page":"SDE Tutorial","title":"Topics covered in this tutorial include:","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"the swing equation\nfixpoint search of ODE systems\nconstructing an SDE problem with NetworkDynamics.jl","category":"page"},{"location":"SDEVertex/#Example:-Fluctuations-in-Power-Grids-1","page":"SDE Tutorial","title":"Example: Fluctuations in Power Grids","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"This tutorial explains the use of stochastic differential equations (SDE's) in NetworkDynamics.jl. As an example system we will simulate fluctuations in a simple power grid model.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"The phase and frequency dynamics in power grids can be modeled by the swing equation. In the complex systems community this is also known as the Kuramoto model with inertia.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"beginaligned\ndot theta_i = omega_i \nM_i dot omega_i = P_i(t) - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)\nendaligned","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Here, M_i and D_i are inertia and damping parameters, K_ij is the power capacitiy of the line and P_i(t) is the power infeed at the node. We assume that this power can be separated into a constant power setpoint P^circ_i and a stochastic fluctuation.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"beginaligned\nP_i(t) = P^circ_i + sigma_i cdot xi_i(t)\nendaligned","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"In this tutorial we assume the fluctuations xi_i(t) to be white Gaussian noise. Separating the deterministic and stochastic part, we can write this problem as a stochastic differential equation.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"beginaligned\ndomega_i = leftP_i - D_i omega_i - sum_i=1^N K_ij sin(theta_i - theta_j)right dt + sigma_i dW_i\nendaligned","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Here, dW_i = xi_i dt is the infinitesimal increment of the Wiener process. Problems of this type can be numerically solved in Julia as described in the SDE Tutorial of DifferentialEquations.","category":"page"},{"location":"SDEVertex/#Implementing-the-Swing-Equation-1","page":"SDE Tutorial","title":"Implementing the Swing Equation","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"First we will implement the node and edge functions for the deterministic case without the fluctuations. We assume the inertia and damping parameters to be M_i = 10 and D_i = 01.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"function swing_equation!(dv, v, e_s, e_d, P, t)\n    dv[1] = v[2]\n    dv[2] = P - 0.1 * v[2]\n    for e in e_s\n        dv[2] -= e[1]\n    end\n    for e in e_d\n        dv[2] += e[1]\n    end\nend\n\nfunction powerflow!(e, v_s, v_d, K, t)\n    e[1] = K * sin(v_s[1] - v_d[1])\nend\nnothing # hide","category":"page"},{"location":"SDEVertex/#Contructing-the-Deterministic-Dynamics-1","page":"SDE Tutorial","title":"Contructing the Deterministic Dynamics","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"For the graph structure we will use a simple 4 node ring network.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"using LightGraphs\ng = watts_strogatz(4, 2, 0.)\nnothing # hide","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Then we can construct the ODEFunction of the deterministic system by using network_dynamics().","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"using NetworkDynamics\n\nswing_vertex = ODEVertex(f! = swing_equation!, dim = 2, sym=[:θ, :ω])\npowerflow_edge = StaticEdge(f! = powerflow!, dim = 1)\n\nnd = network_dynamics(swing_vertex, powerflow_edge, g)\nnothing # hide","category":"page"},{"location":"SDEVertex/#Fixpoint-Search-1","page":"SDE Tutorial","title":"Fixpoint Search","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Now we need to define the dynamic parameters of vertices and edges. For simplicity we assume homogeneous capacities on the lines. For the nodes we assume half of them to be net producers (P = 10) and half of them to be net consumers (P = -10) of power.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"K = 6.0\nP = [1.,-1.,1.,-1.]\np = (P,K)\nnothing # hide","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"We want to simulate fluctuations around an equilibrium state of our model system. Therefore, we need to find a fixpoint of the determinitic system which can be done by using the utility function find_fixpoint(). As an initial guess we take all variables equal to zero.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"u0 = find_fixpoint(nd, p, zeros(8))\n\nusing DifferentialEquations\node_prob = ODEProblem(nd, u0, (0.,1000.), p)\node_sol = solve(ode_prob)\n\nusing Plots, LaTeXStrings\nplot(ode_sol, vars = syms_containing(nd, \"ω\"), ylims = (-1.0, 1.0), ylabel = L\"\\omega\", legend = false)","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"We see that this is in fact a fixpoint solution. We will later use this as an initial condition for the numerical integration of the SDE system.","category":"page"},{"location":"SDEVertex/#Adding-a-Stochastic-Layer-1","page":"SDE Tutorial","title":"Adding a Stochastic Layer","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"For adding the stochastic part of the dynamics we have to define a second graph layer. In our example, the fluctuations at different nodes are independent of each other. Therefore, we define a second graph with the same number of vertices but without any edges.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"h =  SimpleGraph(4, 0)\nnothing # hide","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"The dynamics at the nodes has to have the same dimension as in the deterministic case. In our example we only have fluctuations in the second variable.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"function fluctuation!(dx, x, e_s, e_d, p, t)\n    dx[1] = 0.0\n    dx[2] = 0.05\nend\nnothing # hide","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Now we can construct the dynamics of the second layer by using network_dynamics(). Since the graph structure of the stochastic layer has no edges we can take the edge function of the deterministic case as a placeholder.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"fluctuation_vertex = ODEVertex(f! = fluctuation!, dim = 2)\nnd_noise = network_dynamics(fluctuation_vertex, powerflow_edge, h)\nnothing # hide","category":"page"},{"location":"SDEVertex/#Simulating-the-SDE-1","page":"SDE Tutorial","title":"Simulating the SDE","text":"","category":"section"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"Finally, we can create an SDEProblem and solve it with DifferentialEquations.","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"sde_prob = SDEProblem(nd, nd_noise, u0, (0., 500.), p)\nsde_sol = solve(sde_prob)\nplot(sde_sol, vars = syms_containing(nd, \"ω\"), ylims = (-1.0, 1.0), ylabel = L\"\\omega\", legend = false)","category":"page"},{"location":"SDEVertex/#","page":"SDE Tutorial","title":"SDE Tutorial","text":"More details on SDE problems, e.g. how to include correlations or how to define an EnsembleProblem, can be found in the documentation of DifferentialEquations.","category":"page"},{"location":"getting_started_with_network_dynamics/#getting_started-1","page":"Getting started","title":"Network diffusion","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"This introductory example explains the use of the basic types and constructors in NetworkDynamics.jl by modeling a simple diffusion on an undirected network. A corresponding IJulia notebook is available on GitHub.","category":"page"},{"location":"getting_started_with_network_dynamics/#Theoretical-background-1","page":"Getting started","title":"Theoretical background","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Diffusion processes are relevant for phenomena as diverse as heat conduction, electrical currents, and random walks. Generally speaking they describe the tendency of systems to evolve towards a state of equally distributed heat, charge or concentration. In such system the local temperature (or concentration) changes according to its difference with its neighborhood, i.e. the temperature gradient.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Let g be a graph with N nodes and adjacency matrix A. Let v = (v_1 dots v_n) be a vector of (abstract) temperatures or concentrations at each node i = 1 dots N. Then the rate of change of state v_i is described by its difference with its neighbors and we obtain the following ordinary differential equation","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v_i = - sum_i=1^N A_ij (v_i - v_j)","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The sum on the right hand side plays the role of a (discrete) gradient. If the temperature at node i is higher than at its neighboring node j it will decrease along that edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#Modeling-diffusion-in-NetworkDynamics.jl-1","page":"Getting started","title":"Modeling diffusion in NetworkDynamics.jl","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"From the above considerations we see that in this model the nodes do not have any internal dynamics - if a node was disconnected from the rest of the network its state would never change, since then A_ij = 0  forall j and hence dot v_i = 0. This means that the evolution of a node depends only on the interaction with its neighbors. In NetworkDynamics.jl interactions with neighbors are described by equations for the edges.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"function diffusionedge!(e, v_s, v_d, p, t)\n    # usually e, v_s, v_d are arrays, hence we use the broadcasting operator .\n    e .= v_s - v_d\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The function diffusionedge! takes as inputs the current state of the edge e, its source vertex v_s, its destination vertex v_d, a vector of parameters p and the time t. In order to comply with the syntax of NetworkDynamics.jl we always have to define functions for static edges with exactly these arguments, eventhough we do not need p and t for the diffusion example.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"diffusionedge! is called a mutating function, since it modifies (or mutates) one of its inputs, namely the edge state e. As a convention in julia names of mutating functions end with an !. The use of mutating functions reduces allocations and thereby speeds up computations. After the function call the edge's value e equals the difference between its source and its destination vertex (i.e. the discrete gradient along that edge).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The contributions of the different edges are then summed up in each vertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"function diffusionvertex!(dv, v, e_s, e_d, p, t)\n    # usually v, e_s, e_d are arrays, hence we use the broadcasting operator .\n    dv .= 0.\n    # edges for which v is the source\n    for e in e_s\n        dv .-= e\n    end\n    # edges for which v is the destination\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Just like above the input arguments v, e_s, e_d, p, t are mandatory for the syntax of vertex functions. The additional input dv corresponding to the derivative of the vertex' state is mandatory for vertices described by ordinary differential equations.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Something unexpected happens in the for-loops: The contributions of the connecting edges are subtracted or added depending on v being the source or the destination of an edge. However we are modeling diffusion on an undirected network, hence the concepts of source and destination are not defined!","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The reason for this syntax is found in the LightGraphs.jl package on which NetworkDynamics.jl is based.","category":"page"},{"location":"getting_started_with_network_dynamics/#How-to-deal-with-abstract-edge-directions-in-undirected-graphs-1","page":"Getting started","title":"How to deal with abstract edge directions in undirected graphs","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"LightGraphs.jl implements edges as pairs of node indices i and j. Pairs are basic julia data types consisting of two fixed elements, definded by writing i => j. In directed graphs these pairs additionally represent the direction in which the edge is pointing (from the first two the second element). In undirected graphs every edge is represent by only a single pair i => j if index i is smaller than index j and j => i otherwise. Hence, even for undirected graphs every edge has an abstract direction, specified by the pair of indices of the attached nodes.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"A LightGraphs.jl user, who is only interested in undirected graphs, usually does not have to deal with this abstract directionality. However since NetworkDynamics.jl is interfacing directly to the underlying graph objects, we have to keep in mind that every edge has an abstract direction and thus a source and a destination.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"In the diffusion example the coupling terms have to be modified accordingly. Assume node i is connected to node j by an undirected edge.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Case: i => j","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"If the abstract edge direction points from i to j then the edge value will be v_i - v_j. Hence we have to subtract this term from dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"Case: j => i","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"In this case the edge value is v_j - v_i. Of course that's just -(v_i - v_j) and can be directly added to dv.","category":"page"},{"location":"getting_started_with_network_dynamics/#Caveat:-Symmetric-and-asymmetric-coupling-terms-1","page":"Getting started","title":"Caveat: Symmetric and asymmetric coupling terms","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The coupling term g(i j) = v_i - v_j is anti-symmetric, that is g(ij) = - g(ji) and hence multiplying some edge values with -1 restores the behaviour of undirected edges. The same property holds for other important coupling terms like g(ij) = sin(v_i - v_j). On the other hand, if the coupling term happens to be symmetric, i.e. g(ij) = g(ji) we don't have to worry about the abstract direction at all.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"However, some coupling terms are neither symmetric nor anti-symmetric like the chemical coupling between neurons. In this case it is a viable strategy to double the number of edge variables, compute both outcomes and use only one depending on the abstract direction of the edge. For more details have a look at the example on chemical coupling.","category":"page"},{"location":"getting_started_with_network_dynamics/#Constructing-the-network-1","page":"Getting started","title":"Constructing the network","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"With the preliminaries out of the way, it only takes a few steps to assemble the network dynamics.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using LightGraphs\n\nN = 20 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The Barabási–Albert model generates a scale-free random graph.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using NetworkDynamics\n\nnd_diffusion_vertex = ODEVertex(f! = diffusionvertex!, dim = 1)\nnd_diffusion_edge = StaticEdge(f! = diffusionedge!, dim = 1)\n\nnd = network_dynamics(nd_diffusion_vertex, nd_diffusion_edge, g)\n\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"ODEVertexband StaticEdge are functions wrappers that equip the functions we defined above with additional information like dim and return objects of type VertexFunction and EdgeFunction. Then the key constructor network_dynamics combines them with the topological information contained in the graph g and returns an ODEFunction compatible with the solvers of DifferentialEquations.jl. The keyword dim specifies the number of variables at each edge or node.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using OrdinaryDiffEq\n\nx0 = randn(N) # random initial conditions\node_prob = ODEProblem(nd, x0, (0., 4.))\nsol = solve(ode_prob, Tsit5());\nnothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"We are solving the diffusion problem on the time interval 0 4 with the Tsit5() algorithm, which is recommended  by the authors of DifferentialEquations.jl for most non-stiff problems.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"using Plots\nplot(sol, vars = syms_containing(nd, \"v\"));\nsavefig(\"diff1.svg\"); nothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The plotting is straightforward. The vars keyword allows us to pass a list of indices or symbols specifiying the variables we want to plot. Symbols can be thought of as names given to the interal variables of an ODEFunction, much like the variables x or phi in mathematical notation. The default symbol for vertex variables is v, however we are free to specify other symbols by passing them to the ODEVertex constructor.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"syms_containing is a helper function that returns all symbols of an ODEProblem containg a specific string (or symbol).","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"To illustrate a very simple multi-dimensional case, in the following we simulate two independent diffusions on an identical network. The first uses the symbol x and is started with initial conditions drawn from the standard normal distribution N(01), the second uses the symbol ϕ with squared standard normal inital conditions.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The symbols have to be passed with the keyword sym to ODEVertex.","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"N = 10 # number of nodes\nk = 4  # average degree\ng = barabasi_albert(N, k) # a little more exciting than a bare random graph\n\n# We will have two independent diffusions on the network, hence dim = 2\nnd_diffusion_vertex_2 = ODEVertex(f! = diffusionvertex!, dim = 2, sym = [:x, :ϕ])\nnd_diffusion_edge_2 = StaticEdge(f! = diffusionedge!, dim = 2)\nnd_2 = network_dynamics(nd_diffusion_vertex_2, nd_diffusion_edge_2, g)\n\nx0_2 = vec(transpose([randn(N).^2 randn(N)])) # x ~ N(0,1)^2; ϕ ~ N(0,1)\node_prob_2 = ODEProblem(nd_2, x0_2, (0., 3.))\nsol_2 = solve(ode_prob_2, Tsit5());\n\n\n# Try plotting the variables ϕ_i yourself. [To write ϕ type \\phi and press TAB]\nplot(sol_2, vars = syms_containing(nd_2, \"x\"));\nsavefig(\"diff2.svg\"); nothing # hide","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"(Image: )","category":"page"},{"location":"getting_started_with_network_dynamics/#Appendix:-The-network-Laplacian-L-1","page":"Getting started","title":"Appendix: The network Laplacian L","text":"","category":"section"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"The diffusion equation on a network can be rewritten as","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v_i  = d_i v_i - sum_i=1^N A_ij v_j = d_i v_i - e_i^T A v          ","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"where d_i is the degree of node i and e_i^T is the i-th standard basis vector. Introducing the diagonal matrix D that has the degree of node i in its i-th row and the Laplacian matrix L = D - A we arrive at","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v = e_i^T(D - A) v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"and finally","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"dot v = L v","category":"page"},{"location":"getting_started_with_network_dynamics/#","page":"Getting started","title":"Getting started","text":"This is a linear system of ODEs and its solution is a matrix exponential. To study the asymptotic behaviour of the system it suffices to analyze the eigenspectrum of L. For this reason L is an important construction in network science.","category":"page"},{"location":"#NetworkDynamics-1","page":"General","title":"NetworkDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"A package for working with dynamical systems on complex networks. NetworkDynamics.jl provides an interface between LightGraphs.jl and DifferentialEquations.jl. It allows to define several types of dynamic and static nodes and edges and to link them up in order to create complex network dynamics.","category":"page"},{"location":"#","page":"General","title":"General","text":"At the moment the behaviour of a node or an edge can be described by algebraic equations or by ordinary differential equations (ODE). Support for stochastic differential equations (SDE) and delay differential equations (DDE) will be added in future releases.","category":"page"},{"location":"#Installation-1","page":"General","title":"Installation","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"Installation is straightforward with Julia's package manager.","category":"page"},{"location":"#","page":"General","title":"General","text":"(v1.3) pkg> add NetworkDynamics","category":"page"},{"location":"#PowerDynamics-1","page":"General","title":"PowerDynamics","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"PowerDynamics.jl is an open-source framework for dynamic power grid modeling and analysis build on top of NetworkDynamics.jl.","category":"page"},{"location":"#Overview-1","page":"General","title":"Overview","text":"","category":"section"},{"location":"#","page":"General","title":"General","text":"The key construction is the function network_dynamics that takes in two arrays of functions describing the local dynamics on the edges and nodes of a graph g, and returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"#","page":"General","title":"General","text":"nd = network_dynamics(vertices!::Array{VertexFunction},  edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor network_dynamics assembles the dynamics of the whole network from functions for the single vertices and edges of the graph g. Since the equations describing the local dynamics may differ strongly from each other, the types VertexFunction and EdgeFunction are introduced. They provide a unifying interface between different classes of nodes and edges. Both have several subtypes that account for the different classes of equations that may represent the local dynamics. At the moment algebraic (static) equations and ordinary differential equations (ODEs) are supported:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# VertexFunctions\nStaticVertex(vertexfunction!, dimension, symbol)\nODEVertex(vertexfunction!, dimension, mass_matrix, symbol)\n\n# EdgeFunctions\nStaticEdge(edgefunction!, dimension, symbol)\nODEEdge(edgefunction!, dimension, mass_matrix, symbol)","category":"page"},{"location":"BasicConstructors/#VertexFunctions-1","page":"Functions","title":"VertexFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Given a set of (algebraic or differential) equations describing a node or an edge the first step is to turn them into a mutating function vertexfunction!. Depending on the class of the function vertexfunction!, the constructors StaticVertex or ODEVertex are called in order to turn vertexfunction! into a VertexFunction object compatible with network_dynamics.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Since in general the state of a vertex depends on the vertex value itself as well as on the in- and outgoing edges, the function vertexfunction! has to respect one of the following calling syntaxes.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static nodes\nfunction vertexfunction!(v, e_s, e_d, p, t) end\n# For dynamic nodes\nfunction vertexfunction!(dv, v, e_s, e_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here dv, v, p and t are the usual ODE arguments, while e_s and e_d are arrays containing the edges for which the described vertex is the source or the destination respectively. The typical case of diffusive coupling on a directed graph could be described as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"function vertex!(dv, v, e_s, e_d, p, t)\n    dv .= 0.\n    for e in e_s\n        dv .-= e\n    end\n    for e in e_d\n        dv .+= e\n    end\n    nothing\nend","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"warning: Warning\nThe arguments e_s and e_d are obligatory even if the graph is undirected and no distinction between source and destination can be made. This is necessary since LightGraphs.jl implements an undirected graph in the same way as a directed graphs, but ignores the directionality information. Therefore some care has to be taken when dealing with assymetric coupling terms. A detailed example can be found  in the Getting started tutorial.","category":"page"},{"location":"BasicConstructors/#[StaticVertex](@ref)-1","page":"Functions","title":"StaticVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex is described by an algebraic equation  vertexfunction!(v, e_s, e_d, p, t), i.e. dv = 0 the VertexFunction is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticVertex(vertexfunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Here, dim is the number of independent variables in the vertex equations and sym is an array of symbols for these variables. For example, if a node models a constant input I = p, then dim = 1 and sym = [:I]. For more details on the use of symbols, check out the Getting started tutorial and the Julia documentation. The use of symbols makes it easier to later fish out the interesting variables one wants to look at.","category":"page"},{"location":"BasicConstructors/#[ODEVertex](@ref)-1","page":"Functions","title":"ODEVertex","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If a vertex has local dynamics vertexfunction!(dv, v, e_s, e_d, p, t) described by an ODE the VertexFunction is contructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(vertexfunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"As above, dim is the number of independent variables in the vertex equations and sym corresponds to the symbols of these variables.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"mass_matrix is an optional argument that defaults to the identity matrix I. If a mass matrix M is given the local system M * dv = vertexfunction! will be solved. network_dynamics assembles all local mass matrices into one global mass matrix that can be passed to a differential equation solver like Rodas4.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"One may also call ODEVertex with keyword arguments, omitting optional arguments:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEVertex(f! = vertexfunction!, dim = dim)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The function then defaults to using the identity as mass matrix and [:v for i in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#EdgeFunctions-1","page":"Functions","title":"EdgeFunctions","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Similar to the case of vertices, an edge is described by mutating function edgefunction!. At the moment the constructors StaticEdge and ODEEdge are available. edgefunction! has to respect one of the following syntaxes:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"# For static edges\nfunction edgefunction!(e, v_s, v_d, p, t) end\n# For dynamics edges\nfunction edgefunction!(de, e, v_s, v_d, p, t) end","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Just like above, de, e, p and t are the usual ODE arguments, while v_s and v_d are the source and destination vertices respectively.","category":"page"},{"location":"BasicConstructors/#[StaticEdge](@ref)-1","page":"Functions","title":"StaticEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Static here means, that the edge value described by edgefunction! only depends on the values of the vertices the edge connects to and that no derivative of the edge's internal state is involved. One very simple and natural example is a diffusive edge:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (e, v_s, v_d, p, t) -> e .= v_s .- v_d","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the EdgeFunction is constructed by","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"StaticEdge(edgefunction!, dim, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices.","category":"page"},{"location":"BasicConstructors/#[ODEEdge](@ref)-1","page":"Functions","title":"ODEEdge","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For problems where edgefunction! describes the differential of an edge value, we use the ODEEdge function. An example for such a system is given by:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"edgefunction! = (de, e, v_s, v_d, p, t) -> de .= 1000 * (v_s .- v_d .- e)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The EdgeFunction object is constructed as","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(edgefunction!, dim, mass_matrix, sym)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The keywords are the same as for the vertices. For ODEEdge the same simplified construction rules apply when keyword arguments are used.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"ODEEdge(f! = edgefunction!, dim = n)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"In this case the function defaults to using the identity as mass matrix and [:e for in 1:dimension] as symbols.","category":"page"},{"location":"BasicConstructors/#Constructor-1","page":"Functions","title":"Constructor","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The key constructor is the function network_dynamics that takes in two arrays of EdgeFunctions and VertexFunctions describing the local dynamics on the edges and nodes of a graph g, given as a LightGraphs.jl object. It returns a composite function compatible with the DifferentialEquations.jl calling syntax.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertices!::Array{VertexFunction},\n                      edges!::Array{EdgeFunction}, g)\nnd(dx, x, p, t)","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"If all vertices, respectively edges share the same VertexFunction or EdgeFunction, than network_dynamics can be conveniently called with these functions as arguments.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g)\n","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"The optional keyword argument parallel is false by default and can be set to true if a multi-threaded ODEFunction should be used. This may significantly improve performance on multi-core machines, for more details see section Multi-Threading.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"nd = network_dynamics(vertexfunction!::VertexFunction,\n                      edgefunction!::EdgeFunction, g, parallel=true)\n","category":"page"},{"location":"BasicConstructors/#Example-1","page":"Functions","title":"Example","text":"","category":"section"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Let's look at an example. First we define our graph as well as the differential systems connected to its vertices and edges:","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"using NetworkDynamics, LightGraphs\n\ng = erdos_renyi(10, 25) # random graph with 10 vertices and 25 edges\n\nfunction vertexfunction!(dv, v, e_s, e_d, p, t)\n  dv .= 0\n  for e in e_s\n    dv .-= e\n  end\n  for e in e_d\n    dv .+= e\n  end\nend\n\nfunction edgefunction!(de, e, v_s, v_d, p, t)\n     de .= 1000 .*(v_s .- v_d .- e)\n     nothing\nend\n\nvertex = ODEVertex(f! = vertexfunction!, dim = 1)\nvertexarr = [vertex for v in vertices(g)]\n\nedge = ODEEdge(f! = edgefunction!, dim = 1)\nedgearr = [edge for e in edges(g)]\n\nnd = network_dynamics(vertexarr, edgearr, g)\n\nnothing # hide","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"Now we have an ODEFunction nd that can be solved with the tools provided by DifferentialEquations.jl.","category":"page"},{"location":"BasicConstructors/#","page":"Functions","title":"Functions","text":"For more details check out the Tutorials section.","category":"page"}]
}
